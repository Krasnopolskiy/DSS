# НИЯУ МИФИ. Лабораторная работа №7. Краснопольский Иван, Б21-525. 2024

## SQL сценарии

1. [Создание таблиц](scripts/01-create-tables.sql)
2. [Наполнение данными](scripts/02-populate-tables.sql)
3. [READ COMMITTED - A](scripts/03-read-commited-a.sql)
4. [READ COMMITTED - B](scripts/03-read-commited-b.sql)
5. [REPEATABLE READ - A](scripts/04-repeatable-read-a.sql)
6. [REPEATABLE READ - B](scripts/04-repeatable-read-b.sql)
7. [SERIALIZABLE - A](scripts/05-serializable-a.sql)
8. [SERIALIZABLE - B](scripts/05-serializable-b.sql)

## Изоляция READ COMMITTED

### Транзакция A

```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

UPDATE good
SET price = 19000.00
WHERE name = 'Смартфон XYZ Pro';

INSERT INTO good (id, name, description, price, amount, seller)
VALUES (20, 'Ноутбук ABC Lite', 'Диагональ экрана 15.6 дюймов, видеокарта GTX 1660 Ti.', 19000.00, 10, 1);
```

### Транзакция B

```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

SELECT price
FROM good
WHERE name = 'Смартфон XYZ Pro';

SELECT name
FROM good
WHERE name = 'Ноутбук ABC Lite';

UPDATE good
SET price = 59000.00
WHERE name = 'Смартфон XYZ Pro';
```

#### Данные сессии B до COMMIT сессии A

- Обновленный товар - получена старая цена
- Добавленный товар - запрос ничего не вернул
- Внесение изменений - запрос завис

#### Данные сессии B после ROLLBACK сессии A

- Обновленный товар - получена старая цена
- Добавленный товар - запрос ничего не вернул
- Внесение изменений - запрос выполнился

#### Данные сессии B после COMMIT сессии A

- Обновленный товар - получена новая цена
- Добавленный товар - запрос вернул название добавленного товара
- Внесение изменений - запрос выполнился

#### Обоснование

Неповторяемое чтение разрешено на данном уровне изоляции, поэтому транзакция B может прочитать данные, которые были
обновлены за рамками этой транзакции. Также READ COMMITED позволяет фантомное чтение, поэтому добавленные данные также
доступны. Запрос на добавление изменений завис, так как строчка была заблокирована транзакцией A, и отвис сразу как
только транзакция A была выполнена или отменена.

При выполнении `UPDATE` транзакцией A устанавливается исключительная блокировка на обновляемую строку. Когда вторая
транзакция B пытается изменить те же самые строки, ей придется ждать освобождения блокировки транзакцией A. По этой
причине запрос зависает до завершения транзакции A.

## Изоляция REPEATABLE READ

### Транзакция A

```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

UPDATE good
SET price = 19000.00
WHERE name = 'Смартфон XYZ Pro';

INSERT INTO good (id, name, description, price, amount, seller)
VALUES (20, 'Ноутбук ABC Lite', 'Диагональ экрана 15.6 дюймов, видеокарта GTX 1660 Ti.', 19000.00, 10, 1);
```

### Транзакция B

```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

SELECT price
FROM good
WHERE name = 'Смартфон XYZ Pro';

SELECT name
FROM good
WHERE name = 'Ноутбук ABC Lite';

UPDATE good
SET price = 59000.00
WHERE name = 'Смартфон XYZ Pro';
```

#### Данные сессии B до COMMIT сессии A

- Обновленный товар - получена старая цена
- Добавленный товар - запрос ничего не вернул

#### Данные сессии B после ROLLBACK сессии A

- Обновленный товар - получена старая цена
- Добавленный товар - запрос ничего не вернул

#### Данные сессии B после COMMIT сессии A

- Обновленный товар - получена старая цена
- Добавленный товар - запрос ничего не вернул

#### Обоснование

Dirty read на данном уровне изоляции уже невозможен, поэтому транзакция B не может прочитать данные, которые были
обновлены за рамками этой транзакции. Хотя формально REPETABLE READ позволяет фантомное чтение, PostgreSQL фактически
не позволяет фантомное чтение на этом уровне, поэтому добавленные данные также недоступны.

## Изоляция SERIALIZABLE

### Транзакция A

```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

UPDATE good
SET price = 19000.00
WHERE name = 'Смартфон XYZ Pro';

INSERT INTO good (id, name, description, price, amount, seller)
VALUES (20, 'Ноутбук ABC Lite', 'Диагональ экрана 15.6 дюймов, видеокарта GTX 1660 Ti.', 19000.00, 10, 1);
```

### Транзакция B

```sql
BEGIN;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

SELECT price
FROM good
WHERE name = 'Смартфон XYZ Pro';

SELECT name
FROM good
WHERE name = 'Ноутбук ABC Lite';

UPDATE good
SET price = 59000.00
WHERE name = 'Смартфон XYZ Pro';
```

#### Данные сессии B до COMMIT сессии A

- Обновленный товар - получена старая цена
- Добавленный товар - запрос ничего не вернул

#### Данные сессии B после ROLLBACK сессии A

- Обновленный товар - получена старая цена
- Добавленный товар - запрос ничего не вернул

#### Данные сессии B после COMMIT сессии A

- Получена ошибка - `ERROR: could not serialize access due to concurrent update`

#### Обоснование

При выполнении `UPDATE` транзакции B происходит ошибка сериализации, потому что на уровне изоляции SERIALIZABLE
PostgreSQL стремится эмулировать поведение, при котором все транзакции выглядят так, будто идут последовательно, а не
параллельно. Если СУБД обнаруживает, что из-за пересекающихся действий транзакции A и B невозможно гарантировать
«последовательный» результат, то она вынуждена прервать одну из транзакций.

## Заключение

В ходе данной работы было проведено наблюдение за работой двух транзакций с разными уровнями изоляции:

- `READ COMMITTED`
  Грязное чтение на этом уровне недопустимо, однако неповторяемое и фантомное чтение остаются возможными.
  Когда транзакция A обновляет строку, она ставит на неё исключительную блокировку до завершения. Транзакция B,
  пытающаяся изменить те же данные, зависает в ожидании освобождения блокировки. После того как транзакция A сделает
  COMMIT или ROLLBACK, транзакция B «увидит» новые данные и сможет продолжить свою работу.
- `REPEATABLE READ`
  На этом уровне отсутствует не только возможность грязного чтения, но и фактическое фантомное чтение,
  хотя формально стандарт SQL допускает фантомное чтение в REPEATABLE READ.
  Транзакция B не «видит» данные, которые были обновлены или добавлены в параллельной транзакции A. При этом, если B
  попытается изменить уже заблокированную строку, она будет ждать, пока A не освободит исключительную блокировку.
- `SERIALIZABLE`
  На этом уровне PostgreSQL пытается представить все транзакции так, как если бы они шли строго последовательно, а не
  параллельно. Если при этом возникает конфликт, то СУБД прерывает одну из транзакций с ошибкой:
  ```
  ERROR: could not serialize access due to concurrent update
  ```
